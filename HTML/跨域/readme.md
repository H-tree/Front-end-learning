# 同源策略
如果两个url的协议，域名，端口都相同，称为同源。
浏览器默认两个相同的源之间是可以相互访问资源和操作DOM的。
两个不同的源之间若想要相互访问资源或者操作DOM,那么会有一套基础的安全策略的制约叫做同源策略。
同源策略主要体现在DOM,Web数据和网络三个层面。
## DOM层面
限制不同源的js脚本对当前DOM对象读和写的操作，
opener获取进入搞窗口的页面
opener.document
## 数据层面
同源策略限制了不同源的站点读取当前站点的Cookie,IndexDB,LocalStorage等数据。
## 网络层面
限制通过XMLHttpRequest等方式将站点的数据发送给不同源的站点。
## 权衡
安全性和便利性是相互独立的，如果觉对隔离，无疑是最安全的，但是Web的项目就难以开发，让出一些安全性满足灵活性。
## XSS攻击
跨站脚本攻击,指黑客往HTML文件中或DOM中注入恶意脚本
### 存储型XSS攻击
1.将恶意代码提交到数据库中，
2.用户向网站请求包含恶意脚本的页面
3.用户浏览时，恶意脚本将用户的Cookie信息等数据上传到服务器。
### 反射型XSS攻击
### 基于DOM的XSS攻击
网络劫持,WIFI路由器劫持等在Web资源传输过程或用户使用页面过程中修改页面数据
## 策略
### 过滤或转码
将script标签过滤，或者把箭头转义
### 使用HttpOnly属性
将某些Cookie设置为HttpOnly属性，
只能使用在HTTP请求过程中,无法通过JS来读取这段Cookie
### 利用CSP策略
限制其他域下的资源文件
禁止向第三方域提交资源
## CSRF攻击
CSRF跨站请求伪造
SameSite有三个值
Strict:完全禁止第三方Cookie.
Lax: 相对宽松一点,在跨站点的情况下,
None:在任何情况下都会发生Cookie数据。
# 解决
## jsonp
原理:利用script标签中的src属性不会被同源策略所拦截这一机制，将我们要请求的url地址添加到script的src属性中。且携带上前端全局下的一个函数名作为参数传给后端,后端获取前端传递的函数名，返回该函数的调用语法，将要返回的数据放在该函数的调用中作为参数，当浏览器接收到全局下的函数调用响应时，会自动执行该函数，从而从参数获取到后端的返回数据。
缺点:
1.需要对方的服务器做支持才可以
2.只支持get请求，有局限性.
## cors
cors是一个标准，允许浏览器向跨域服务器发XMLHttpRequest请求,跨域的核心是后端响应的内容被浏览器拦截，如果后端也遵从cors标准的话，后端的响应也可以跨域
- 简单请求
  使用get,post,head
  Content-Type的值仅限于
  text/plain || multipart/form-data || application/x-www-form-urnencoded
- 复杂请求
- 不满足简单请求的条件就是复杂请求
- 复杂请求的cors请求，会在正式通信之前，增加一次http查询请求，称为"预检",用来知道服务端是否允许跨域请求，预检发的是option